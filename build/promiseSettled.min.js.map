{"version":3,"sources":["main.js"],"names":["inject","PromiseConstructor","extName","Promise","Error","promises","onProgress","map","promise","then","value","status","e","Function","all","root","self","global","define","amd","module","exports","PromiseSettled"],"mappings":";;;;;;CAKA,WAYA,QAAAA,GAAAC,EAAAC,GAWA,GAVA,gBAAAD,KACAC,EAAAD,GAGAC,EAAA,gBAAAA,GAAAA,EAAA,aAEAD,EACA,kBAAAA,IAAAA,GACA,kBAAAE,UAAAA,SAAA,MAEAF,EACA,KAAA,IAAAG,OAAA,kEAuCA,OAxBAH,GAAAC,GAAA,SAAAG,EAAAC,GAqBA,MApBAD,GAAAA,EAAAE,IAAA,SAAAC,GACA,MAAAA,GAAAC,KAAA,SAAAC,GACA,OACAA,MAAAA,EACAC,QAAA,IAEA,SAAAC,GACA,OACAF,MAAAE,EACAD,QAAA,KAEAF,KAAA,SAAAC,GAKA,MAJAJ,aAAAO,WACAP,EAAAI,GAGAA,MAIAP,QAAAW,IAAAT,IAGAJ,EAGA,GAAAc,GAAA,gBAAAC,OAAAA,KAAAA,OAAAA,MAAAA,MACA,gBAAAC,SAAAA,OAAAA,SAAAA,QAAAA,MAEA,mBAAAC,SAAAA,OAAAC,IACAD,OAAA,WACA,MAAAlB,KAEA,gBAAAoB,SAAAA,QAAAA,OAAAC,QACAD,OAAAC,QAAArB,EAEAe,EAAAO,eAAAtB","file":"promiseSettled.min.js","sourcesContent":["/**\n * promise-ext-settled - Simple settled promise\n * @version v1.0.0\n * @link https://github.com/smelukov/PromiseSettled#readme\n * @license MIT\n */\n/**\n * @licence\n * @author Sergey Melyukov 2016\n */\n\n(function() {\n\t/**\n\t * Inject method with name `extName` to `PromiseConstructor`\n\t *\n\t * @param {Function|String=} PromiseConstructor which constructor should be extended\n\t *                           If not defined, then default promise-constructor will be used\n\t * @param {String=} extName name of the method. If not defined, then 'allSettled' will be used\n\t *\n\t * @returns {Function}\n\t *\n\t * @throws {Error}\n\t */\n\tfunction inject(PromiseConstructor, extName) {\n\t\tif (typeof PromiseConstructor === 'string') {\n\t\t\textName = PromiseConstructor;\n\t\t}\n\n\t\textName = typeof extName === 'string' ? extName : 'allSettled';\n\n\t\tPromiseConstructor =\n\t\t\t(typeof PromiseConstructor === 'function' && PromiseConstructor) ||\n\t\t\t(typeof Promise === 'function' && Promise) || null;\n\n\t\tif (!PromiseConstructor) {\n\t\t\tthrow new Error('Wrong constructor is passed or browser doesn\\'t support promises');\n\t\t}\n\n\t\t/**\n\t\t * Waiting while all promises will be settled to onFulfilled or onRejected state\n\t\t * Returned promise will be resolved with array with info for every passed promise:\n\t\t * Array<{status:boolean, value:*}>\n\t\t *\n\t\t * onProgress-function will be called (if passed) for every settled promise\n\t\t *\n\t\t * @param {Array<Promise>} promises\n\t\t * @param {function({status:boolean, value:*})} onProgress\n\t\t *\n\t\t * @return {Promise}\n\t\t */\n\t\tPromiseConstructor[extName] = function(promises, onProgress) {\n\t\t\tpromises = promises.map(function(promise) {\n\t\t\t\treturn promise.then(function(value) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tstatus: true\n\t\t\t\t\t};\n\t\t\t\t}, function(e) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: e,\n\t\t\t\t\t\tstatus: false\n\t\t\t\t\t};\n\t\t\t\t}).then(function(value) {\n\t\t\t\t\tif (onProgress instanceof Function) {\n\t\t\t\t\t\tonProgress(value);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn Promise.all(promises);\n\t\t};\n\n\t\treturn PromiseConstructor;\n\t}\n\n\tvar root = (typeof self == 'object' && self.self === self && self) ||\n\t\t(typeof global == 'object' && global.global === global && global);\n\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(function() {\n\t\t\treturn inject;\n\t\t});\n\t} else if (typeof module === 'object' && module && module.exports) {\n\t\tmodule.exports = inject;\n\t} else {\n\t\troot.PromiseSettled = inject;\n\t}\n})();\n"],"sourceRoot":"../src"}